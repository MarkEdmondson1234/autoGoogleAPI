% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/serviceuser_objects.R
\name{HttpRule}
\alias{HttpRule}
\title{HttpRule Object}
\usage{
HttpRule(put = NULL, delete = NULL, body = NULL, mediaDownload = NULL,
  post = NULL, additionalBindings = NULL, responseBody = NULL,
  mediaUpload = NULL, selector = NULL, custom = NULL, patch = NULL,
  get = NULL)
}
\arguments{
\item{put}{Used for updating a resource}

\item{delete}{Used for deleting a resource}

\item{body}{The name of the request field whose value is mapped to the HTTP body, or}

\item{mediaDownload}{Use this only for Scotty Requests}

\item{post}{Used for creating a resource}

\item{additionalBindings}{Additional HTTP bindings for the selector}

\item{responseBody}{The name of the response field whose value is mapped to the HTTP body of}

\item{mediaUpload}{Use this only for Scotty Requests}

\item{selector}{Selects methods to which this rule applies}

\item{custom}{Custom pattern is used for defining custom verbs}

\item{patch}{Used for updating a resource}

\item{get}{Used for listing and getting information about resources}
}
\value{
HttpRule object
}
\description{
HttpRule Object
}
\details{
Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
`HttpRule` defines the mapping of an RPC method to one or more HTTPREST APIs.  The mapping determines what portions of the requestmessage are populated from the path, query parameters, or body ofthe HTTP request.  The mapping is typically specified as an`google.api.http` annotation, see 'google/api/annotations.proto'for details.The mapping consists of a field specifying the path template andmethod kind.  The path template can refer to fields in the requestmessage, as in the example below which describes a REST GEToperation on a resource collection of messages:    service Messaging {      rpc GetMessage(GetMessageRequest) returns (Message) {        option (google.api.http).get = '/v1/messages/{message_id}/{sub.subfield}';      }    }    message GetMessageRequest {      message SubMessage {        string subfield = 1;      }      string message_id = 1; // mapped to the URL      SubMessage sub = 2;    // `sub.subfield` is url-mapped    }    message Message {      string text = 1; // content of the resource    }The same http annotation can alternatively be expressed inside the`GRPC API Configuration` YAML file.    http:      rules:        - selector: <proto_package_name>.Messaging.GetMessage          get: /v1/messages/{message_id}/{sub.subfield}This definition enables an automatic, bidrectional mapping of HTTPJSON to RPC. Example:HTTP | RPC-----|-----`GET /v1/messages/123456/foo`  | `GetMessage(message_id: '123456' sub: SubMessage(subfield: 'foo'))`In general, not only fields but also field paths can be referencedfrom a path pattern. Fields mapped to the path pattern cannot berepeated and must have a primitive (non-message) type.Any fields in the request message which are not bound by the pathpattern automatically become (optional) HTTP queryparameters. Assume the following definition of the request message:    message GetMessageRequest {      message SubMessage {        string subfield = 1;      }      string message_id = 1; // mapped to the URL      int64 revision = 2;    // becomes a parameter      SubMessage sub = 3;    // `sub.subfield` becomes a parameter    }This enables a HTTP JSON to RPC mapping as below:HTTP | RPC-----|-----`GET /v1/messages/123456?revision=2&sub.subfield=foo` | `GetMessage(message_id: '123456' revision: 2 sub: SubMessage(subfield: 'foo'))`Note that fields which are mapped to HTTP parameters must have aprimitive type or a repeated primitive type. Message types are notallowed. In the case of a repeated type, the parameter can berepeated in the URL, as in `...?param=A&param=B`.For HTTP method kinds which allow a request body, the `body` fieldspecifies the mapping. Consider a REST update method on themessage resource collection:    service Messaging {      rpc UpdateMessage(UpdateMessageRequest) returns (Message) {        option (google.api.http) = {          put: '/v1/messages/{message_id}'          body: 'message'        };      }    }    message UpdateMessageRequest {      string message_id = 1; // mapped to the URL      Message message = 2;   // mapped to the body    }The following HTTP JSON to RPC mapping is enabled, where therepresentation of the JSON in the request body is determined byprotos JSON encoding:HTTP | RPC-----|-----`PUT /v1/messages/123456 { 'text': 'Hi!' }` | `UpdateMessage(message_id: '123456' message { text: 'Hi!' })`The special name `*` can be used in the body mapping to define thatevery field not bound by the path template should be mapped to therequest body.  This enables the following alternative definition ofthe update method:    service Messaging {      rpc UpdateMessage(Message) returns (Message) {        option (google.api.http) = {          put: '/v1/messages/{message_id}'          body: '*'        };      }    }    message Message {      string message_id = 1;      string text = 2;    }The following HTTP JSON to RPC mapping is enabled:HTTP | RPC-----|-----`PUT /v1/messages/123456 { 'text': 'Hi!' }` | `UpdateMessage(message_id: '123456' text: 'Hi!')`Note that when using `*` in the body mapping, it is not possible tohave HTTP parameters, as all fields not bound by the path end inthe body. This makes this option more rarely used in practice ofdefining REST APIs. The common usage of `*` is in custom methodswhich don't use the URL at all for transferring data.It is possible to define multiple HTTP methods for one RPC by usingthe `additional_bindings` option. Example:    service Messaging {      rpc GetMessage(GetMessageRequest) returns (Message) {        option (google.api.http) = {          get: '/v1/messages/{message_id}'          additional_bindings {            get: '/v1/users/{user_id}/messages/{message_id}'          }        };      }    }    message GetMessageRequest {      string message_id = 1;      string user_id = 2;    }This enables the following two alternative HTTP JSON to RPCmappings:HTTP | RPC-----|-----`GET /v1/messages/123456` | `GetMessage(message_id: '123456')``GET /v1/users/me/messages/123456` | `GetMessage(user_id: 'me' message_id: '123456')`# Rules for HTTP mappingThe rules for mapping HTTP path, query parameters, and body fieldsto the request message are as follows:1. The `body` field specifies either `*` or a field path, or is   omitted. If omitted, it assumes there is no HTTP body.2. Leaf fields (recursive expansion of nested messages in the   request) can be classified into three types:    (a) Matched in the URL template.    (b) Covered by body (if body is `*`, everything except (a) fields;        else everything under the body field)    (c) All other fields.3. URL query parameters found in the HTTP request are mapped to (c) fields.4. Any body sent with an HTTP request can contain only (b) fields.The syntax of the path template is as follows:    Template = '/' Segments [ Verb ] ;    Segments = Segment { '/' Segment } ;    Segment  = '*' | '**' | LITERAL | Variable ;    Variable = '{' FieldPath [ '=' Segments ] '}' ;    FieldPath = IDENT { '.' IDENT } ;    Verb     = ':' LITERAL ;The syntax `*` matches a single path segment. It follows the semantics of[RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple StringExpansion.The syntax `**` matches zero or more path segments. It follows the semanticsof [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.3 ReservedExpansion. NOTE: it must be the last segment in the path except the Verb.The syntax `LITERAL` matches literal text in the URL path.The syntax `Variable` matches the entire path as specified by its template;this nested template must not contain further variables. If a variablematches a single path segment, its template may be omitted, e.g. `{var}`is equivalent to `{var=*}`.NOTE: the field paths in variables and in the `body` must not refer torepeated fields or map fields.Use CustomHttpPattern to specify any HTTP method that is not included in the`pattern` field, such as HEAD, or '*' to leave the HTTP method unspecified fora given URL path rule. The wild-card rule is useful for services that providecontent to Web (HTML) clients.
}
