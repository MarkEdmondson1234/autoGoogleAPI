% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spanner_objects.R
\name{TransactionOptions}
\alias{TransactionOptions}
\title{TransactionOptions Object}
\usage{
TransactionOptions(readWrite = NULL, readOnly = NULL)
}
\arguments{
\item{readWrite}{Transaction may write}

\item{readOnly}{Transaction will not write}
}
\value{
TransactionOptions object
}
\description{
TransactionOptions Object
}
\details{
Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
# TransactionsEach session can have at most one active transaction at a time. After theactive transaction is completed, the session can immediately bere-used for the next transaction. It is not necessary to create anew session for each transaction.# Transaction ModesCloud Spanner supports two transaction modes:  1. Locking read-write. This type of transaction is the only way     to write data into Cloud Spanner. These transactions rely on     pessimistic locking and, if necessary, two-phase commit.     Locking read-write transactions may abort, requiring the     application to retry.  2. Snapshot read-only. This transaction type provides guaranteed     consistency across several reads, but does not allow     writes. Snapshot read-only transactions can be configured to     read at timestamps in the past. Snapshot read-only     transactions do not need to be committed.For transactions that only read, snapshot read-only transactionsprovide simpler semantics and are almost always faster. Inparticular, read-only transactions do not take locks, so they donot conflict with read-write transactions. As a consequence of nottaking locks, they also do not abort, so retry loops are not needed.Transactions may only read/write data in a single database. Theymay, however, read/write data in different tables within thatdatabase.## Locking Read-Write TransactionsLocking transactions may be used to atomically read-modify-writedata anywhere in a database. This type of transaction is externallyconsistent.Clients should attempt to minimize the amount of time a transactionis active. Faster transactions commit with higher probabilityand cause less contention. Cloud Spanner attempts to keep read locksactive as long as the transaction continues to do reads, and thetransaction has not been terminated byCommit orRollback.  Long periods ofinactivity at the client may cause Cloud Spanner to release atransaction's locks and abort it.Reads performed within a transaction acquire locks on the databeing read. Writes can only be done at commit time, after all readshave been completed.Conceptually, a read-write transaction consists of zero or morereads or SQL queries followed byCommit. At any time beforeCommit, the client can send aRollback request to abort thetransaction.### SemanticsCloud Spanner can commit the transaction if all read locks it acquiredare still valid at commit time, and it is able to acquire writelocks for all writes. Cloud Spanner can abort the transaction for anyreason. If a commit attempt returns `ABORTED`, Cloud Spanner guaranteesthat the transaction has not modified any user data in Cloud Spanner.Unless the transaction commits, Cloud Spanner makes no guarantees abouthow long the transaction's locks were held for. It is an error touse Cloud Spanner locks for any sort of mutual exclusion other thanbetween Cloud Spanner transactions themselves.### Retrying Aborted TransactionsWhen a transaction aborts, the application can choose to retry thewhole transaction again. To maximize the chances of successfullycommitting the retry, the client should execute the retry in thesame session as the original attempt. The original session's lockpriority increases with each consecutive abort, meaning that eachattempt has a slightly better chance of success than the previous.Under some circumstances (e.g., many transactions attempting tomodify the same row(s)), a transaction can abort many times in ashort period before successfully committing. Thus, it is not a goodidea to cap the number of retries a transaction can attempt;instead, it is better to limit the total amount of wall time spentretrying.### Idle TransactionsA transaction is considered idle if it has no outstanding reads orSQL queries and has not started a read or SQL query within the last 10seconds. Idle transactions can be aborted by Cloud Spanner so that theydon't hold on to locks indefinitely. In that case, the commit willfail with error `ABORTED`.If this behavior is undesirable, periodically executing a simpleSQL query in the transaction (e.g., `SELECT 1`) prevents thetransaction from becoming idle.## Snapshot Read-Only TransactionsSnapshot read-only transactions provides a simpler method thanlocking read-write transactions for doing several consistentreads. However, this type of transaction does not support writes.Snapshot transactions do not take locks. Instead, they work bychoosing a Cloud Spanner timestamp, then executing all reads at thattimestamp. Since they do not acquire locks, they do not blockconcurrent read-write transactions.Unlike locking read-write transactions, snapshot read-onlytransactions never abort. They can fail if the chosen readtimestamp is garbage collected; however, the default garbagecollection policy is generous enough that most applications do notneed to worry about this in practice.Snapshot read-only transactions do not need to callCommit orRollback (and in fact are notpermitted to do so).To execute a snapshot transaction, the client specifies a timestampbound, which tells Cloud Spanner how to choose a read timestamp.The types of timestamp bound are:  - Strong (the default).  - Bounded staleness.  - Exact staleness.If the Cloud Spanner database to be read is geographically distributed,stale read-only transactions can execute more quickly than strongor read-write transaction, because they are able to execute farfrom the leader replica.Each type of timestamp bound is discussed in detail below.### StrongStrong reads are guaranteed to see the effects of all transactionsthat have committed before the start of the read. Furthermore, allrows yielded by a single read are consistent with each other -- ifany part of the read observes a transaction, all parts of the readsee the transaction.Strong reads are not repeatable: two consecutive strong read-onlytransactions might return inconsistent results if there areconcurrent writes. If consistency across reads is required, thereads should be executed within a transaction or at an exact readtimestamp.See TransactionOptions.ReadOnly.strong.### Exact StalenessThese timestamp bounds execute reads at a user-specifiedtimestamp. Reads at a timestamp are guaranteed to see a consistentprefix of the global transaction history: they observemodifications done by all transactions with a commit timestamp <=the read timestamp, and observe none of the modifications done bytransactions with a larger commit timestamp. They will block untilall conflicting transactions that may be assigned commit timestamps<= the read timestamp have finished.The timestamp can either be expressed as an absolute Cloud Spanner committimestamp or a staleness relative to the current time.These modes do not require a 'negotiation phase' to pick atimestamp. As a result, they execute slightly faster than theequivalent boundedly stale concurrency modes. On the other hand,boundedly stale reads usually return fresher results.See TransactionOptions.ReadOnly.read_timestamp andTransactionOptions.ReadOnly.exact_staleness.### Bounded StalenessBounded staleness modes allow Cloud Spanner to pick the read timestamp,subject to a user-provided staleness bound. Cloud Spanner chooses thenewest timestamp within the staleness bound that allows executionof the reads at the closest available replica without blocking.All rows yielded are consistent with each other -- if any part ofthe read observes a transaction, all parts of the read see thetransaction. Boundedly stale reads are not repeatable: two stalereads, even if they use the same staleness bound, can execute atdifferent timestamps and thus return inconsistent results.Boundedly stale reads execute in two phases: the first phasenegotiates a timestamp among all replicas needed to serve theread. In the second phase, reads are executed at the negotiatedtimestamp.As a result of the two phase execution, bounded staleness reads areusually a little slower than comparable exact stalenessreads. However, they are typically able to return fresherresults, and are more likely to execute at the closest replica.Because the timestamp negotiation requires up-front knowledge ofwhich rows will be read, it can only be used with single-useread-only transactions.See TransactionOptions.ReadOnly.max_staleness andTransactionOptions.ReadOnly.min_read_timestamp.### Old Read Timestamps and Garbage CollectionCloud Spanner continuously garbage collects deleted and overwritten datain the background to reclaim storage space. This process is knownas 'version GC'. By default, version GC reclaims versions after theyare one hour old. Because of this, Cloud Spanner cannot perform readsat read timestamps more than one hour in the past. Thisrestriction also applies to in-progress reads and/or SQL queries whosetimestamp become too old while executing. Reads and SQL queries withtoo-old read timestamps fail with the error `FAILED_PRECONDITION`.
}
