#' Cloud Spanner API Objects 
#' Cloud Spanner is a managed, mission-critical, globally consistent and scalable relational database service.
#' 
#' Auto-generated code by googleAuthR::gar_create_api_objects
#'  at 2017-03-05 20:15:07
#' filename: /Users/mark/dev/R/autoGoogleAPI/googlespannerv1.auto/R/spanner_objects.R
#' api_json: api_json
#' 
#' Objects for use by the functions created by googleAuthR::gar_create_api_skeleton

#' TransactionSelector Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' This message is used to select the transaction in which aRead orExecuteSql call runs.See TransactionOptions for more information about transactions.
#' 
#' @param id Execute the read or SQL query in a previously-started transaction
#' @param singleUse Execute the read or SQL query in a temporary transaction
#' @param begin Begin a new transaction and execute this read or SQL query in
#' 
#' @return TransactionSelector object
#' 
#' @family TransactionSelector functions
#' @export
TransactionSelector <- function(id = NULL, singleUse = NULL, begin = NULL) {
    structure(list(id = id, singleUse = singleUse, begin = begin), class = "gar_TransactionSelector")
}

#' KeySet Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' `KeySet` defines a collection of Cloud Spanner keys and/or key ranges. Allthe keys are expected to be in the same table or index. The keys neednot be sorted in any particular way.If the same key is specified multiple times in the set (for exampleif two ranges, two keys, or a key and a range overlap), Cloud Spannerbehaves as if the key were only specified once.
#' 
#' @param keys A list of specific keys
#' @param all For convenience `all` can be set to `true` to indicate that this
#' @param ranges A list of key ranges
#' 
#' @return KeySet object
#' 
#' @family KeySet functions
#' @export
KeySet <- function(keys = NULL, all = NULL, ranges = NULL) {
    structure(list(keys = keys, all = all, ranges = ranges), class = "gar_KeySet")
}

#' Mutation Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A modification to one or more Cloud Spanner rows.  Mutations can beapplied to a Cloud Spanner database by sending them in aCommit call.
#' 
#' @param delete Delete rows from a table
#' @param insert Insert new rows in a table
#' @param insertOrUpdate Like insert, except that if the row already exists, then
#' @param update Update existing rows in a table
#' @param replace Like insert, except that if the row already exists, it is
#' 
#' @return Mutation object
#' 
#' @family Mutation functions
#' @export
Mutation <- function(delete = NULL, insert = NULL, insertOrUpdate = NULL, update = NULL, 
    replace = NULL) {
    structure(list(delete = delete, insert = insert, insertOrUpdate = insertOrUpdate, 
        update = update, replace = replace), class = "gar_Mutation")
}

#' GetDatabaseDdlResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response for GetDatabaseDdl.
#' 
#' @param statements A list of formatted DDL statements defining the schema of the database
#' 
#' @return GetDatabaseDdlResponse object
#' 
#' @family GetDatabaseDdlResponse functions
#' @export
GetDatabaseDdlResponse <- function(statements = NULL) {
    structure(list(statements = statements), class = "gar_GetDatabaseDdlResponse")
}

#' Database Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A Cloud Spanner database.
#' 
#' @param state Output only
#' @param name Required
#' 
#' @return Database object
#' 
#' @family Database functions
#' @export
Database <- function(state = NULL, name = NULL) {
    structure(list(state = state, name = name), class = "gar_Database")
}

#' ListDatabasesResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response for ListDatabases.
#' 
#' @param nextPageToken `next_page_token` can be sent in a subsequent
#' @param databases Databases that matched the request
#' 
#' @return ListDatabasesResponse object
#' 
#' @family ListDatabasesResponse functions
#' @export
ListDatabasesResponse <- function(nextPageToken = NULL, databases = NULL) {
    structure(list(nextPageToken = nextPageToken, databases = databases), class = "gar_ListDatabasesResponse")
}

#' Instance Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' An isolated set of Cloud Spanner resources on which databases can be hosted.
#' 
#' @param Instance.labels The \link{Instance.labels} object or list of objects
#' @param displayName Required
#' @param nodeCount Required
#' @param labels Cloud Labels are a flexible and lightweight mechanism for organizing cloud
#' @param state Output only
#' @param config Required
#' @param name Required
#' 
#' @return Instance object
#' 
#' @family Instance functions
#' @export
Instance <- function(Instance.labels = NULL, displayName = NULL, nodeCount = NULL, 
    labels = NULL, state = NULL, config = NULL, name = NULL) {
    structure(list(Instance.labels = Instance.labels, displayName = displayName, 
        nodeCount = nodeCount, labels = labels, state = state, config = config, name = name), 
        class = "gar_Instance")
}

#' Instance.labels Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Cloud Labels are a flexible and lightweight mechanism for organizing cloudresources into groups that reflect a customer's organizational needs anddeployment strategies. Cloud Labels can be used to filter collections ofresources. They can be used to control how resource metrics are aggregated.And they can be used as arguments to policy management rules (e.g. route,firewall, load balancing, etc.). * Label keys must be between 1 and 63 characters long and must conform to   the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`. * Label values must be between 0 and 63 characters long and must conform   to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`. * No more than 64 labels can be associated with a given resource.See https://goo.gl/xmQnxf for more information on and examples of labels.If you plan to use labels in your own code, please note that additionalcharacters may be allowed in the future. And so you are advised to use aninternal label representation, such as JSON, which doesn't rely uponspecific characters being disallowed.  For example, representing labelsas the string:  name + '_' + value  would prove problematic if we were toallow '_' in a future release.
#' 
#' 
#' 
#' @return Instance.labels object
#' 
#' @family Instance functions
#' @export
Instance.labels <- function() {
    list()
}

#' SetIamPolicyRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Request message for `SetIamPolicy` method.
#' 
#' @param policy REQUIRED: The complete policy to be applied to the `resource`
#' @param updateMask OPTIONAL: A FieldMask specifying which fields of the policy to modify
#' 
#' @return SetIamPolicyRequest object
#' 
#' @family SetIamPolicyRequest functions
#' @export
SetIamPolicyRequest <- function(policy = NULL, updateMask = NULL) {
    structure(list(policy = policy, updateMask = updateMask), class = "gar_SetIamPolicyRequest")
}

#' RollbackRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for Rollback.
#' 
#' @param transactionId Required
#' 
#' @return RollbackRequest object
#' 
#' @family RollbackRequest functions
#' @export
RollbackRequest <- function(transactionId = NULL) {
    structure(list(transactionId = transactionId), class = "gar_RollbackRequest")
}

#' Transaction Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A transaction.
#' 
#' @param id `id` may be used to identify the transaction in subsequent
#' @param readTimestamp For snapshot read-only transactions, the read timestamp chosen
#' 
#' @return Transaction object
#' 
#' @family Transaction functions
#' @export
Transaction <- function(id = NULL, readTimestamp = NULL) {
    structure(list(id = id, readTimestamp = readTimestamp), class = "gar_Transaction")
}

#' UpdateDatabaseDdlMetadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata type for the operation returned byUpdateDatabaseDdl.
#' 
#' @param statements For an update this list contains all the statements
#' @param commitTimestamps Reports the commit timestamps of all statements that have
#' @param database The database being modified
#' 
#' @return UpdateDatabaseDdlMetadata object
#' 
#' @family UpdateDatabaseDdlMetadata functions
#' @export
UpdateDatabaseDdlMetadata <- function(statements = NULL, commitTimestamps = NULL, 
    database = NULL) {
    structure(list(statements = statements, commitTimestamps = commitTimestamps, 
        database = database), class = "gar_UpdateDatabaseDdlMetadata")
}

#' CounterOptions Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Options for counters
#' 
#' @param metric The metric to update
#' @param field The field value to attribute
#' 
#' @return CounterOptions object
#' 
#' @family CounterOptions functions
#' @export
CounterOptions <- function(metric = NULL, field = NULL) {
    structure(list(metric = metric, field = field), class = "gar_CounterOptions")
}

#' QueryPlan Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Contains an ordered list of nodes appearing in the query plan.
#' 
#' @param planNodes The nodes in the query plan
#' 
#' @return QueryPlan object
#' 
#' @family QueryPlan functions
#' @export
QueryPlan <- function(planNodes = NULL) {
    structure(list(planNodes = planNodes), class = "gar_QueryPlan")
}

#' StructType Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' `StructType` defines the fields of a STRUCT type.
#' 
#' @param fields The list of fields that make up this struct
#' 
#' @return StructType object
#' 
#' @family StructType functions
#' @export
StructType <- function(fields = NULL) {
    structure(list(fields = fields), class = "gar_StructType")
}

#' Field Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Message representing a single field of a struct.
#' 
#' @param type The type of the field
#' @param name The name of the field
#' 
#' @return Field object
#' 
#' @family Field functions
#' @export
Field <- function(type = NULL, name = NULL) {
    structure(list(type = type, name = name), class = "gar_Field")
}

#' ResultSetStats Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Additional statistics about a ResultSet or PartialResultSet.
#' 
#' @param ResultSetStats.queryStats The \link{ResultSetStats.queryStats} object or list of objects
#' @param queryStats Aggregated statistics from the execution of the query
#' @param queryPlan QueryPlan for the query associated with this result
#' 
#' @return ResultSetStats object
#' 
#' @family ResultSetStats functions
#' @export
ResultSetStats <- function(ResultSetStats.queryStats = NULL, queryStats = NULL, queryPlan = NULL) {
    structure(list(ResultSetStats.queryStats = ResultSetStats.queryStats, queryStats = queryStats, 
        queryPlan = queryPlan), class = "gar_ResultSetStats")
}

#' ResultSetStats.queryStats Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Aggregated statistics from the execution of the query. Only present whenthe query is profiled. For example, a query could return the statistics asfollows:    {      'rows_returned': '3',      'elapsed_time': '1.22 secs',      'cpu_time': '1.19 secs'    }
#' 
#' 
#' 
#' @return ResultSetStats.queryStats object
#' 
#' @family ResultSetStats functions
#' @export
ResultSetStats.queryStats <- function() {
    list()
}

#' TestIamPermissionsRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Request message for `TestIamPermissions` method.
#' 
#' @param permissions REQUIRED: The set of permissions to check for 'resource'
#' 
#' @return TestIamPermissionsRequest object
#' 
#' @family TestIamPermissionsRequest functions
#' @export
TestIamPermissionsRequest <- function(permissions = NULL) {
    structure(list(permissions = permissions), class = "gar_TestIamPermissionsRequest")
}

#' CommitResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response for Commit.
#' 
#' @param commitTimestamp The Cloud Spanner timestamp at which the transaction committed
#' 
#' @return CommitResponse object
#' 
#' @family CommitResponse functions
#' @export
CommitResponse <- function(commitTimestamp = NULL) {
    structure(list(commitTimestamp = commitTimestamp), class = "gar_CommitResponse")
}

#' Type Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' `Type` indicates the type of a Cloud Spanner value, as might be stored in atable cell or returned from an SQL query.
#' 
#' @param structType If code == STRUCT, then `struct_type`
#' @param arrayElementType If code == ARRAY, then `array_element_type`
#' @param code Required
#' 
#' @return Type object
#' 
#' @family Type functions
#' @export
Type <- function(structType = NULL, arrayElementType = NULL, code = NULL) {
    structure(list(structType = structType, arrayElementType = arrayElementType, 
        code = code), class = "gar_Type")
}

#' PlanNode Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Node information for nodes appearing in a QueryPlan.plan_nodes.
#' 
#' @param PlanNode.metadata The \link{PlanNode.metadata} object or list of objects
#' @param PlanNode.executionStats The \link{PlanNode.executionStats} object or list of objects
#' @param metadata Attributes relevant to the node contained in a group of key-value pairs
#' @param executionStats The execution statistics associated with the node, contained in a group of
#' @param shortRepresentation Condensed representation for SCALAR nodes
#' @param index The `PlanNode`'s index in node list
#' @param displayName The display name for the node
#' @param childLinks List of child node `index`es and their relationship to this parent
#' 
#' @return PlanNode object
#' 
#' @family PlanNode functions
#' @export
PlanNode <- function(PlanNode.metadata = NULL, PlanNode.executionStats = NULL, metadata = NULL, 
    executionStats = NULL, shortRepresentation = NULL, index = NULL, displayName = NULL, 
    childLinks = NULL) {
    structure(list(PlanNode.metadata = PlanNode.metadata, PlanNode.executionStats = PlanNode.executionStats, 
        metadata = metadata, executionStats = executionStats, shortRepresentation = shortRepresentation, 
        index = index, displayName = displayName, kind = kind, childLinks = childLinks), 
        class = "gar_PlanNode")
}

#' PlanNode.metadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Attributes relevant to the node contained in a group of key-value pairs.For example, a Parameter Reference node could have the followinginformation in its metadata:    {      'parameter_reference': 'param1',      'parameter_type': 'array'    }
#' 
#' 
#' 
#' @return PlanNode.metadata object
#' 
#' @family PlanNode functions
#' @export
PlanNode.metadata <- function() {
    list()
}

#' PlanNode.executionStats Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The execution statistics associated with the node, contained in a group ofkey-value pairs. Only present if the plan was returned as a result of aprofile query. For example, number of executions, number of rows/time perexecution etc.
#' 
#' 
#' 
#' @return PlanNode.executionStats object
#' 
#' @family PlanNode functions
#' @export
PlanNode.executionStats <- function() {
    list()
}

#' AuditConfig Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Specifies the audit configuration for a service.It consists of which permission types are logged, and what identities, ifany, are exempted from logging.An AuditConifg must have one or more AuditLogConfigs.
#' 
#' @param service Specifies a service that will be enabled for audit logging
#' @param auditLogConfigs The configuration for logging of each type of permission
#' @param exemptedMembers Specifies the identities that are exempted from 'data access' audit
#' 
#' @return AuditConfig object
#' 
#' @family AuditConfig functions
#' @export
AuditConfig <- function(service = NULL, auditLogConfigs = NULL, exemptedMembers = NULL) {
    structure(list(service = service, auditLogConfigs = auditLogConfigs, exemptedMembers = exemptedMembers), 
        class = "gar_AuditConfig")
}

#' CreateInstanceMetadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata type for the operation returned byCreateInstance.
#' 
#' @param instance The instance being created
#' @param startTime The time at which the
#' @param cancelTime The time at which this operation was cancelled
#' @param endTime The time at which this operation failed or was completed successfully
#' 
#' @return CreateInstanceMetadata object
#' 
#' @family CreateInstanceMetadata functions
#' @export
CreateInstanceMetadata <- function(instance = NULL, startTime = NULL, cancelTime = NULL, 
    endTime = NULL) {
    structure(list(instance = instance, startTime = startTime, cancelTime = cancelTime, 
        endTime = endTime), class = "gar_CreateInstanceMetadata")
}

#' ChildLink Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata associated with a parent-child relationship appearing in aPlanNode.
#' 
#' @param type The type of the link
#' @param childIndex The node to which the link points
#' @param variable Only present if the child node is SCALAR and corresponds
#' 
#' @return ChildLink object
#' 
#' @family ChildLink functions
#' @export
ChildLink <- function(type = NULL, childIndex = NULL, variable = NULL) {
    structure(list(type = type, childIndex = childIndex, variable = variable), class = "gar_ChildLink")
}

#' CloudAuditOptions Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Write a Cloud Audit log
#' 
#' 
#' 
#' @return CloudAuditOptions object
#' 
#' @family CloudAuditOptions functions
#' @export
CloudAuditOptions <- function() {
    list()
}

#' Delete Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Arguments to delete operations.
#' 
#' @param table Required
#' @param keySet Required
#' 
#' @return Delete object
#' 
#' @family Delete functions
#' @export
Delete <- function(table = NULL, keySet = NULL) {
    structure(list(table = table, keySet = keySet), class = "gar_Delete")
}

#' BeginTransactionRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for BeginTransaction.
#' 
#' @param options Required
#' 
#' @return BeginTransactionRequest object
#' 
#' @family BeginTransactionRequest functions
#' @export
BeginTransactionRequest <- function(options = NULL) {
    structure(list(options = options), class = "gar_BeginTransactionRequest")
}

#' ListInstanceConfigsResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response for ListInstanceConfigs.
#' 
#' @param nextPageToken `next_page_token` can be sent in a subsequent
#' @param instanceConfigs The list of requested instance configurations
#' 
#' @return ListInstanceConfigsResponse object
#' 
#' @family ListInstanceConfigsResponse functions
#' @export
ListInstanceConfigsResponse <- function(nextPageToken = NULL, instanceConfigs = NULL) {
    structure(list(nextPageToken = nextPageToken, instanceConfigs = instanceConfigs), 
        class = "gar_ListInstanceConfigsResponse")
}

#' CommitRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for Commit.
#' 
#' @param singleUseTransaction Execute mutations in a temporary transaction
#' @param mutations The mutations to be executed when this transaction commits
#' @param transactionId Commit a previously-started transaction
#' 
#' @return CommitRequest object
#' 
#' @family CommitRequest functions
#' @export
CommitRequest <- function(singleUseTransaction = NULL, mutations = NULL, transactionId = NULL) {
    structure(list(singleUseTransaction = singleUseTransaction, mutations = mutations, 
        transactionId = transactionId), class = "gar_CommitRequest")
}

#' GetIamPolicyRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Request message for `GetIamPolicy` method.
#' 
#' 
#' 
#' @return GetIamPolicyRequest object
#' 
#' @family GetIamPolicyRequest functions
#' @export
GetIamPolicyRequest <- function() {
    list()
}

#' TestIamPermissionsResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Response message for `TestIamPermissions` method.
#' 
#' @param permissions A subset of `TestPermissionsRequest
#' 
#' @return TestIamPermissionsResponse object
#' 
#' @family TestIamPermissionsResponse functions
#' @export
TestIamPermissionsResponse <- function(permissions = NULL) {
    structure(list(permissions = permissions), class = "gar_TestIamPermissionsResponse")
}

#' CreateDatabaseMetadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata type for the operation returned byCreateDatabase.
#' 
#' @param database The database being created
#' 
#' @return CreateDatabaseMetadata object
#' 
#' @family CreateDatabaseMetadata functions
#' @export
CreateDatabaseMetadata <- function(database = NULL) {
    structure(list(database = database), class = "gar_CreateDatabaseMetadata")
}

#' Rule Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A rule to be applied in a Policy.
#' 
#' @param notIn If one or more 'not_in' clauses are specified, the rule matches
#' @param description Human-readable description of the rule
#' @param conditions Additional restrictions that must be met
#' @param logConfig The config returned to callers of tech
#' @param in. If one or more 'in' clauses are specified, the rule matches if
#' @param permissions A permission is a string of form '<service>
#' @param action Required
#' 
#' @return Rule object
#' 
#' @family Rule functions
#' @export
Rule <- function(notIn = NULL, description = NULL, conditions = NULL, logConfig = NULL, 
    in. = NULL, permissions = NULL, action = NULL) {
    structure(list(notIn = notIn, description = description, conditions = conditions, 
        logConfig = logConfig, `in` = in., permissions = permissions, action = action), 
        class = "gar_Rule")
}

#' LogConfig Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Specifies what kind of log the caller must writeIncrement a streamz counter with the specified metric and field names.Metric names should start with a '/', generally be lowercase-only,and end in '_count'. Field names should not contain an initial slash.The actual exported metric names will have '/iam/policy' prepended.Field names correspond to IAM request parameters and field values aretheir respective values.At present the only supported field names are   - 'iam_principal', corresponding to IAMContext.principal;   - '' (empty string), resulting in one aggretated counter with no field.Examples:  counter { metric: '/debug_access_count'  field: 'iam_principal' }  ==> increment counter /iam/policy/backend_debug_access_count                        {iam_principal=[value of IAMContext.principal]}At this time we do not support:* multiple field names (though this may be supported in the future)* decrementing the counter* incrementing it by anything other than 1
#' 
#' @param cloudAudit Cloud audit options
#' @param counter Counter options
#' @param dataAccess Data access options
#' 
#' @return LogConfig object
#' 
#' @family LogConfig functions
#' @export
LogConfig <- function(cloudAudit = NULL, counter = NULL, dataAccess = NULL) {
    structure(list(cloudAudit = cloudAudit, counter = counter, dataAccess = dataAccess), 
        class = "gar_LogConfig")
}

#' Session Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A session in the Cloud Spanner API.
#' 
#' @param name Required
#' 
#' @return Session object
#' 
#' @family Session functions
#' @export
Session <- function(name = NULL) {
    structure(list(name = name), class = "gar_Session")
}

#' ListInstancesResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response for ListInstances.
#' 
#' @param instances The list of requested instances
#' @param nextPageToken `next_page_token` can be sent in a subsequent
#' 
#' @return ListInstancesResponse object
#' 
#' @family ListInstancesResponse functions
#' @export
ListInstancesResponse <- function(instances = NULL, nextPageToken = NULL) {
    structure(list(instances = instances, nextPageToken = nextPageToken), class = "gar_ListInstancesResponse")
}

#' KeyRange Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' KeyRange represents a range of rows in a table or index.A range has a start key and an end key. These keys can be open orclosed, indicating if the range includes rows with that key.Keys are represented by lists, where the ith value in the listcorresponds to the ith component of the table or index primary key.Individual values are encoded as described here.For example, consider the following table definition:    CREATE TABLE UserEvents (      UserName STRING(MAX),      EventDate STRING(10)    ) PRIMARY KEY(UserName, EventDate);The following keys name rows in this table:    'Bob', '2014-09-23'Since the `UserEvents` table's `PRIMARY KEY` clause names twocolumns, each `UserEvents` key has two elements; the first is the`UserName`, and the second is the `EventDate`.Key ranges with multiple components are interpretedlexicographically by component using the table or index key's declaredsort order. For example, the following range returns all events foruser `'Bob'` that occurred in the year 2015:    'start_closed': ['Bob', '2015-01-01']    'end_closed': ['Bob', '2015-12-31']Start and end keys can omit trailing key components. This affects theinclusion and exclusion of rows that exactly match the provided keycomponents: if the key is closed, then rows that exactly match theprovided components are included; if the key is open, then rowsthat exactly match are not included.For example, the following range includes all events for `'Bob'` thatoccurred during and after the year 2000:    'start_closed': ['Bob', '2000-01-01']    'end_closed': ['Bob']The next example retrieves all events for `'Bob'`:    'start_closed': ['Bob']    'end_closed': ['Bob']To retrieve events before the year 2000:    'start_closed': ['Bob']    'end_open': ['Bob', '2000-01-01']The following range includes all rows in the table:    'start_closed': []    'end_closed': []This range returns all users whose `UserName` begins with anycharacter from A to C:    'start_closed': ['A']    'end_open': ['D']This range returns all users whose `UserName` begins with B:    'start_closed': ['B']    'end_open': ['C']Key ranges honor column sort order. For example, suppose a table isdefined as follows:    CREATE TABLE DescendingSortedTable {      Key INT64,      ...    ) PRIMARY KEY(Key DESC);The following range retrieves all rows with key values between 1and 100 inclusive:    'start_closed': ['100']    'end_closed': ['1']Note that 100 is passed as the start, and 1 is passed as the end,because `Key` is a descending column in the schema.
#' 
#' @param startClosed If the start is closed, then the range includes all rows whose
#' @param startOpen If the start is open, then the range excludes rows whose first
#' @param endOpen If the end is open, then the range excludes rows whose first
#' @param endClosed If the end is closed, then the range includes all rows whose
#' 
#' @return KeyRange object
#' 
#' @family KeyRange functions
#' @export
KeyRange <- function(startClosed = NULL, startOpen = NULL, endOpen = NULL, endClosed = NULL) {
    structure(list(startClosed = startClosed, startOpen = startOpen, endOpen = endOpen, 
        endClosed = endClosed), class = "gar_KeyRange")
}

#' ShortRepresentation Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Condensed representation of a node and its subtree. Only present for`SCALAR` PlanNode(s).
#' 
#' @param ShortRepresentation.subqueries The \link{ShortRepresentation.subqueries} object or list of objects
#' @param description A string representation of the expression subtree rooted at this node
#' @param subqueries A mapping of (subquery variable name) -> (subquery node id) for cases
#' 
#' @return ShortRepresentation object
#' 
#' @family ShortRepresentation functions
#' @export
ShortRepresentation <- function(ShortRepresentation.subqueries = NULL, description = NULL, 
    subqueries = NULL) {
    structure(list(ShortRepresentation.subqueries = ShortRepresentation.subqueries, 
        description = description, subqueries = subqueries), class = "gar_ShortRepresentation")
}

#' ShortRepresentation.subqueries Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A mapping of (subquery variable name) -> (subquery node id) for caseswhere the `description` string of this node references a `SCALAR`subquery contained in the expression subtree rooted at this node. Thereferenced `SCALAR` subquery may not necessarily be a direct child ofthis node.
#' 
#' 
#' 
#' @return ShortRepresentation.subqueries object
#' 
#' @family ShortRepresentation functions
#' @export
ShortRepresentation.subqueries <- function() {
    list()
}

#' InstanceConfig Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A possible configuration for a Cloud Spanner instance. Configurationsdefine the geographic placement of nodes and their replication.
#' 
#' @param name A unique identifier for the instance configuration
#' @param displayName The name of this instance configuration as it appears in UIs
#' 
#' @return InstanceConfig object
#' 
#' @family InstanceConfig functions
#' @export
InstanceConfig <- function(name = NULL, displayName = NULL) {
    structure(list(name = name, displayName = displayName), class = "gar_InstanceConfig")
}

#' UpdateInstanceRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for UpdateInstance.
#' 
#' @param instance Required
#' @param fieldMask Required
#' 
#' @return UpdateInstanceRequest object
#' 
#' @family UpdateInstanceRequest functions
#' @export
UpdateInstanceRequest <- function(instance = NULL, fieldMask = NULL) {
    structure(list(instance = instance, fieldMask = fieldMask), class = "gar_UpdateInstanceRequest")
}

#' Empty Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A generic empty message that you can re-use to avoid defining duplicatedempty messages in your APIs. A typical example is to use it as the requestor the response type of an API method. For instance:    service Foo {      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);    }The JSON representation for `Empty` is empty JSON object `{}`.
#' 
#' 
#' 
#' @return Empty object
#' 
#' @family Empty functions
#' @export
Empty <- function() {
    list()
}

#' TransactionOptions Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' # TransactionsEach session can have at most one active transaction at a time. After theactive transaction is completed, the session can immediately bere-used for the next transaction. It is not necessary to create anew session for each transaction.# Transaction ModesCloud Spanner supports two transaction modes:  1. Locking read-write. This type of transaction is the only way     to write data into Cloud Spanner. These transactions rely on     pessimistic locking and, if necessary, two-phase commit.     Locking read-write transactions may abort, requiring the     application to retry.  2. Snapshot read-only. This transaction type provides guaranteed     consistency across several reads, but does not allow     writes. Snapshot read-only transactions can be configured to     read at timestamps in the past. Snapshot read-only     transactions do not need to be committed.For transactions that only read, snapshot read-only transactionsprovide simpler semantics and are almost always faster. Inparticular, read-only transactions do not take locks, so they donot conflict with read-write transactions. As a consequence of nottaking locks, they also do not abort, so retry loops are not needed.Transactions may only read/write data in a single database. Theymay, however, read/write data in different tables within thatdatabase.## Locking Read-Write TransactionsLocking transactions may be used to atomically read-modify-writedata anywhere in a database. This type of transaction is externallyconsistent.Clients should attempt to minimize the amount of time a transactionis active. Faster transactions commit with higher probabilityand cause less contention. Cloud Spanner attempts to keep read locksactive as long as the transaction continues to do reads, and thetransaction has not been terminated byCommit orRollback.  Long periods ofinactivity at the client may cause Cloud Spanner to release atransaction's locks and abort it.Reads performed within a transaction acquire locks on the databeing read. Writes can only be done at commit time, after all readshave been completed.Conceptually, a read-write transaction consists of zero or morereads or SQL queries followed byCommit. At any time beforeCommit, the client can send aRollback request to abort thetransaction.### SemanticsCloud Spanner can commit the transaction if all read locks it acquiredare still valid at commit time, and it is able to acquire writelocks for all writes. Cloud Spanner can abort the transaction for anyreason. If a commit attempt returns `ABORTED`, Cloud Spanner guaranteesthat the transaction has not modified any user data in Cloud Spanner.Unless the transaction commits, Cloud Spanner makes no guarantees abouthow long the transaction's locks were held for. It is an error touse Cloud Spanner locks for any sort of mutual exclusion other thanbetween Cloud Spanner transactions themselves.### Retrying Aborted TransactionsWhen a transaction aborts, the application can choose to retry thewhole transaction again. To maximize the chances of successfullycommitting the retry, the client should execute the retry in thesame session as the original attempt. The original session's lockpriority increases with each consecutive abort, meaning that eachattempt has a slightly better chance of success than the previous.Under some circumstances (e.g., many transactions attempting tomodify the same row(s)), a transaction can abort many times in ashort period before successfully committing. Thus, it is not a goodidea to cap the number of retries a transaction can attempt;instead, it is better to limit the total amount of wall time spentretrying.### Idle TransactionsA transaction is considered idle if it has no outstanding reads orSQL queries and has not started a read or SQL query within the last 10seconds. Idle transactions can be aborted by Cloud Spanner so that theydon't hold on to locks indefinitely. In that case, the commit willfail with error `ABORTED`.If this behavior is undesirable, periodically executing a simpleSQL query in the transaction (e.g., `SELECT 1`) prevents thetransaction from becoming idle.## Snapshot Read-Only TransactionsSnapshot read-only transactions provides a simpler method thanlocking read-write transactions for doing several consistentreads. However, this type of transaction does not support writes.Snapshot transactions do not take locks. Instead, they work bychoosing a Cloud Spanner timestamp, then executing all reads at thattimestamp. Since they do not acquire locks, they do not blockconcurrent read-write transactions.Unlike locking read-write transactions, snapshot read-onlytransactions never abort. They can fail if the chosen readtimestamp is garbage collected; however, the default garbagecollection policy is generous enough that most applications do notneed to worry about this in practice.Snapshot read-only transactions do not need to callCommit orRollback (and in fact are notpermitted to do so).To execute a snapshot transaction, the client specifies a timestampbound, which tells Cloud Spanner how to choose a read timestamp.The types of timestamp bound are:  - Strong (the default).  - Bounded staleness.  - Exact staleness.If the Cloud Spanner database to be read is geographically distributed,stale read-only transactions can execute more quickly than strongor read-write transaction, because they are able to execute farfrom the leader replica.Each type of timestamp bound is discussed in detail below.### StrongStrong reads are guaranteed to see the effects of all transactionsthat have committed before the start of the read. Furthermore, allrows yielded by a single read are consistent with each other -- ifany part of the read observes a transaction, all parts of the readsee the transaction.Strong reads are not repeatable: two consecutive strong read-onlytransactions might return inconsistent results if there areconcurrent writes. If consistency across reads is required, thereads should be executed within a transaction or at an exact readtimestamp.See TransactionOptions.ReadOnly.strong.### Exact StalenessThese timestamp bounds execute reads at a user-specifiedtimestamp. Reads at a timestamp are guaranteed to see a consistentprefix of the global transaction history: they observemodifications done by all transactions with a commit timestamp <=the read timestamp, and observe none of the modifications done bytransactions with a larger commit timestamp. They will block untilall conflicting transactions that may be assigned commit timestamps<= the read timestamp have finished.The timestamp can either be expressed as an absolute Cloud Spanner committimestamp or a staleness relative to the current time.These modes do not require a 'negotiation phase' to pick atimestamp. As a result, they execute slightly faster than theequivalent boundedly stale concurrency modes. On the other hand,boundedly stale reads usually return fresher results.See TransactionOptions.ReadOnly.read_timestamp andTransactionOptions.ReadOnly.exact_staleness.### Bounded StalenessBounded staleness modes allow Cloud Spanner to pick the read timestamp,subject to a user-provided staleness bound. Cloud Spanner chooses thenewest timestamp within the staleness bound that allows executionof the reads at the closest available replica without blocking.All rows yielded are consistent with each other -- if any part ofthe read observes a transaction, all parts of the read see thetransaction. Boundedly stale reads are not repeatable: two stalereads, even if they use the same staleness bound, can execute atdifferent timestamps and thus return inconsistent results.Boundedly stale reads execute in two phases: the first phasenegotiates a timestamp among all replicas needed to serve theread. In the second phase, reads are executed at the negotiatedtimestamp.As a result of the two phase execution, bounded staleness reads areusually a little slower than comparable exact stalenessreads. However, they are typically able to return fresherresults, and are more likely to execute at the closest replica.Because the timestamp negotiation requires up-front knowledge ofwhich rows will be read, it can only be used with single-useread-only transactions.See TransactionOptions.ReadOnly.max_staleness andTransactionOptions.ReadOnly.min_read_timestamp.### Old Read Timestamps and Garbage CollectionCloud Spanner continuously garbage collects deleted and overwritten datain the background to reclaim storage space. This process is knownas 'version GC'. By default, version GC reclaims versions after theyare one hour old. Because of this, Cloud Spanner cannot perform readsat read timestamps more than one hour in the past. Thisrestriction also applies to in-progress reads and/or SQL queries whosetimestamp become too old while executing. Reads and SQL queries withtoo-old read timestamps fail with the error `FAILED_PRECONDITION`.
#' 
#' @param readWrite Transaction may write
#' @param readOnly Transaction will not write
#' 
#' @return TransactionOptions object
#' 
#' @family TransactionOptions functions
#' @export
TransactionOptions <- function(readWrite = NULL, readOnly = NULL) {
    structure(list(readWrite = readWrite, readOnly = readOnly), class = "gar_TransactionOptions")
}

#' CreateDatabaseRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for CreateDatabase.
#' 
#' @param createStatement Required
#' @param extraStatements An optional list of DDL statements to run inside the newly created
#' 
#' @return CreateDatabaseRequest object
#' 
#' @family CreateDatabaseRequest functions
#' @export
CreateDatabaseRequest <- function(createStatement = NULL, extraStatements = NULL) {
    structure(list(createStatement = createStatement, extraStatements = extraStatements), 
        class = "gar_CreateDatabaseRequest")
}

#' CreateInstanceRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for CreateInstance.
#' 
#' @param instanceId Required
#' @param instance Required
#' 
#' @return CreateInstanceRequest object
#' 
#' @family CreateInstanceRequest functions
#' @export
CreateInstanceRequest <- function(instanceId = NULL, instance = NULL) {
    structure(list(instanceId = instanceId, instance = instance), class = "gar_CreateInstanceRequest")
}

#' Condition Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' A condition to be met.
#' 
#' @param svc Trusted attributes discharged by the service
#' @param sys Trusted attributes supplied by any service that owns resources and uses
#' @param value DEPRECATED
#' @param iam Trusted attributes supplied by the IAM system
#' @param values The objects of the condition
#' @param op An operator to apply the subject with
#' 
#' @return Condition object
#' 
#' @family Condition functions
#' @export
Condition <- function(svc = NULL, sys = NULL, value = NULL, iam = NULL, values = NULL, 
    op = NULL) {
    structure(list(svc = svc, sys = sys, value = value, iam = iam, values = values, 
        op = op), class = "gar_Condition")
}

#' AuditLogConfig Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Provides the configuration for logging a type of permissions.Example:    {      'audit_log_configs': [        {          'log_type': 'DATA_READ',          'exempted_members': [            'user:foo@gmail.com'          ]        },        {          'log_type': 'DATA_WRITE',        }      ]    }This enables 'DATA_READ' and 'DATA_WRITE' logging, while exemptingfoo@gmail.com from DATA_READ logging.
#' 
#' @param exemptedMembers Specifies the identities that do not cause logging for this type of
#' @param logType The log type that this config enables
#' 
#' @return AuditLogConfig object
#' 
#' @family AuditLogConfig functions
#' @export
AuditLogConfig <- function(exemptedMembers = NULL, logType = NULL) {
    structure(list(exemptedMembers = exemptedMembers, logType = logType), class = "gar_AuditLogConfig")
}

#' ReadOnly Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Options for read-only transactions.
#' 
#' @param minReadTimestamp Executes all reads at a timestamp >= `min_read_timestamp`
#' @param maxStaleness Read data at a timestamp >= `NOW - max_staleness`
#' @param readTimestamp Executes all reads at the given timestamp
#' @param returnReadTimestamp If true, the Cloud Spanner-selected read timestamp is included in
#' @param exactStaleness Executes all reads at a timestamp that is `exact_staleness`
#' @param strong Read at a timestamp where all previously committed transactions
#' 
#' @return ReadOnly object
#' 
#' @family ReadOnly functions
#' @export
ReadOnly <- function(minReadTimestamp = NULL, maxStaleness = NULL, readTimestamp = NULL, 
    returnReadTimestamp = NULL, exactStaleness = NULL, strong = NULL) {
    structure(list(minReadTimestamp = minReadTimestamp, maxStaleness = maxStaleness, 
        readTimestamp = readTimestamp, returnReadTimestamp = returnReadTimestamp, 
        exactStaleness = exactStaleness, strong = strong), class = "gar_ReadOnly")
}

#' ExecuteSqlRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for ExecuteSql andExecuteStreamingSql.
#' 
#' @param ExecuteSqlRequest.paramTypes The \link{ExecuteSqlRequest.paramTypes} object or list of objects
#' @param ExecuteSqlRequest.params The \link{ExecuteSqlRequest.params} object or list of objects
#' @param transaction The transaction to use
#' @param resumeToken If this request is resuming a previously interrupted SQL query
#' @param paramTypes It is not always possible for Cloud Spanner to infer the right SQL type
#' @param sql Required
#' @param params The SQL query string can contain parameter placeholders
#' @param queryMode Used to control the amount of debugging information returned in
#' 
#' @return ExecuteSqlRequest object
#' 
#' @family ExecuteSqlRequest functions
#' @export
ExecuteSqlRequest <- function(ExecuteSqlRequest.paramTypes = NULL, ExecuteSqlRequest.params = NULL, 
    transaction = NULL, resumeToken = NULL, paramTypes = NULL, sql = NULL, params = NULL, 
    queryMode = NULL) {
    structure(list(ExecuteSqlRequest.paramTypes = ExecuteSqlRequest.paramTypes, ExecuteSqlRequest.params = ExecuteSqlRequest.params, 
        transaction = transaction, resumeToken = resumeToken, paramTypes = paramTypes, 
        sql = sql, params = params, queryMode = queryMode), class = "gar_ExecuteSqlRequest")
}

#' ExecuteSqlRequest.paramTypes Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' It is not always possible for Cloud Spanner to infer the right SQL typefrom a JSON value.  For example, values of type `BYTES` and valuesof type `STRING` both appear in params as JSON strings.In these cases, `param_types` can be used to specify the exactSQL type for some or all of the SQL query parameters. See thedefinition of Type for more informationabout SQL types.
#' 
#' 
#' 
#' @return ExecuteSqlRequest.paramTypes object
#' 
#' @family ExecuteSqlRequest functions
#' @export
ExecuteSqlRequest.paramTypes <- function() {
    list()
}

#' ExecuteSqlRequest.params Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The SQL query string can contain parameter placeholders. A parameterplaceholder consists of `'@'` followed by the parametername. Parameter names consist of any combination of letters,numbers, and underscores.Parameters can appear anywhere that a literal value is expected.  The sameparameter name can be used more than once, for example:  `'WHERE id > @msg_id AND id < @msg_id + 100'`It is an error to execute an SQL query with unbound parameters.Parameter values are specified using `params`, which is a JSONobject whose keys are parameter names, and whose values are thecorresponding parameter values.
#' 
#' 
#' 
#' @return ExecuteSqlRequest.params object
#' 
#' @family ExecuteSqlRequest functions
#' @export
ExecuteSqlRequest.params <- function() {
    list()
}

#' Policy Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Defines an Identity and Access Management (IAM) policy. It is used tospecify access control policies for Cloud Platform resources.A `Policy` consists of a list of `bindings`. A `Binding` binds a list of`members` to a `role`, where the members can be user accounts, Google groups,Google domains, and service accounts. A `role` is a named list of permissionsdefined by IAM.**Example**    {      'bindings': [        {          'role': 'roles/owner',          'members': [            'user:mike@example.com',            'group:admins@example.com',            'domain:google.com',            'serviceAccount:my-other-app@appspot.gserviceaccount.com',          ]        },        {          'role': 'roles/viewer',          'members': ['user:sean@example.com']        }      ]    }For a description of IAM and its features, see the[IAM developer's guide](https://cloud.google.com/iam).
#' 
#' @param etag `etag` is used for optimistic concurrency control as a way to help
#' @param iamOwned No description
#' @param rules If more than one rule is specified, the rules are applied in the following
#' @param version Version of the `Policy`
#' @param auditConfigs Specifies cloud audit logging configuration for this policy
#' @param bindings Associates a list of `members` to a `role`
#' 
#' @return Policy object
#' 
#' @family Policy functions
#' @export
Policy <- function(etag = NULL, iamOwned = NULL, rules = NULL, version = NULL, auditConfigs = NULL, 
    bindings = NULL) {
    structure(list(etag = etag, iamOwned = iamOwned, rules = rules, version = version, 
        auditConfigs = auditConfigs, bindings = bindings), class = "gar_Policy")
}

#' ReadRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The request for Read andStreamingRead.
#' 
#' @param limit If greater than zero, only the first `limit` rows are yielded
#' @param index If non-empty, the name of an index on table
#' @param keySet Required
#' @param columns The columns of table to be returned for each row matching
#' @param transaction The transaction to use
#' @param resumeToken If this request is resuming a previously interrupted read,
#' @param table Required
#' 
#' @return ReadRequest object
#' 
#' @family ReadRequest functions
#' @export
ReadRequest <- function(limit = NULL, index = NULL, keySet = NULL, columns = NULL, 
    transaction = NULL, resumeToken = NULL, table = NULL) {
    structure(list(limit = limit, index = index, keySet = keySet, columns = columns, 
        transaction = transaction, resumeToken = resumeToken, table = table), class = "gar_ReadRequest")
}

#' Write Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Arguments to insert, update, insert_or_update, andreplace operations.
#' 
#' @param columns The names of the columns in table to be written
#' @param values The values to be written
#' @param table Required
#' 
#' @return Write object
#' 
#' @family Write functions
#' @export
Write <- function(columns = NULL, values = NULL, table = NULL) {
    structure(list(columns = columns, values = values, table = table), class = "gar_Write")
}

#' ReadWrite Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Options for read-write transactions.
#' 
#' 
#' 
#' @return ReadWrite object
#' 
#' @family ReadWrite functions
#' @export
ReadWrite <- function() {
    list()
}

#' DataAccessOptions Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Write a Data Access (Gin) log
#' 
#' 
#' 
#' @return DataAccessOptions object
#' 
#' @family DataAccessOptions functions
#' @export
DataAccessOptions <- function() {
    list()
}

#' Operation Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' This resource represents a long-running operation that is the result of anetwork API call.
#' 
#' @param Operation.response The \link{Operation.response} object or list of objects
#' @param Operation.metadata The \link{Operation.metadata} object or list of objects
#' @param done If the value is `false`, it means the operation is still in progress
#' @param response The normal response of the operation in case of success
#' @param name The server-assigned name, which is only unique within the same service that
#' @param error The error result of the operation in case of failure or cancellation
#' @param metadata Service-specific metadata associated with the operation
#' 
#' @return Operation object
#' 
#' @family Operation functions
#' @export
Operation <- function(Operation.response = NULL, Operation.metadata = NULL, done = NULL, 
    response = NULL, name = NULL, error = NULL, metadata = NULL) {
    structure(list(Operation.response = Operation.response, Operation.metadata = Operation.metadata, 
        done = done, response = response, name = name, error = error, metadata = metadata), 
        class = "gar_Operation")
}

#' Operation.response Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The normal response of the operation in case of success.  If the originalmethod returns no data on success, such as `Delete`, the response is`google.protobuf.Empty`.  If the original method is standard`Get`/`Create`/`Update`, the response should be the resource.  For othermethods, the response should have the type `XxxResponse`, where `Xxx`is the original method name.  For example, if the original method nameis `TakeSnapshot()`, the inferred response type is`TakeSnapshotResponse`.
#' 
#' 
#' 
#' @return Operation.response object
#' 
#' @family Operation functions
#' @export
Operation.response <- function() {
    list()
}

#' Operation.metadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Service-specific metadata associated with the operation.  It typicallycontains progress information and common metadata such as create time.Some services might not provide such metadata.  Any method that returns along-running operation should document the metadata type, if any.
#' 
#' 
#' 
#' @return Operation.metadata object
#' 
#' @family Operation functions
#' @export
Operation.metadata <- function() {
    list()
}

#' ResultSet Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Results from Read orExecuteSql.
#' 
#' @param metadata Metadata about the result set, such as row type information
#' @param stats Query plan and execution statistics for the query that produced this
#' @param rows Each element in `rows` is a row whose format is defined by
#' 
#' @return ResultSet object
#' 
#' @family ResultSet functions
#' @export
ResultSet <- function(metadata = NULL, stats = NULL, rows = NULL) {
    structure(list(metadata = metadata, stats = stats, rows = rows), class = "gar_ResultSet")
}

#' Status Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The `Status` type defines a logical error model that is suitable for differentprogramming environments, including REST APIs and RPC APIs. It is used by[gRPC](https://github.com/grpc). The error model is designed to be:- Simple to use and understand for most users- Flexible enough to meet unexpected needs# OverviewThe `Status` message contains three pieces of data: error code, error message,and error details. The error code should be an enum value ofgoogle.rpc.Code, but it may accept additional error codes if needed.  Theerror message should be a developer-facing English message that helpsdevelopers *understand* and *resolve* the error. If a localized user-facingerror message is needed, put the localized message in the error details orlocalize it in the client. The optional error details may contain arbitraryinformation about the error. There is a predefined set of error detail typesin the package `google.rpc` which can be used for common error conditions.# Language mappingThe `Status` message is the logical representation of the error model, but itis not necessarily the actual wire format. When the `Status` message isexposed in different client libraries and different wire protocols, it can bemapped differently. For example, it will likely be mapped to some exceptionsin Java, but more likely mapped to some error codes in C.# Other usesThe error model and the `Status` message can be used in a variety ofenvironments, either with or without APIs, to provide aconsistent developer experience across different environments.Example uses of this error model include:- Partial errors. If a service needs to return partial errors to the client,    it may embed the `Status` in the normal response to indicate the partial    errors.- Workflow errors. A typical workflow has multiple steps. Each step may    have a `Status` message for error reporting purpose.- Batch operations. If a client uses batch request and batch response, the    `Status` message should be used directly inside batch response, one for    each error sub-response.- Asynchronous operations. If an API call embeds asynchronous operation    results in its response, the status of those operations should be    represented directly using the `Status` message.- Logging. If some API errors are stored in logs, the message `Status` could    be used directly after any stripping needed for security/privacy reasons.
#' 
#' @param message A developer-facing error message, which should be in English
#' @param details A list of messages that carry the error details
#' @param code The status code, which should be an enum value of google
#' 
#' @return Status object
#' 
#' @family Status functions
#' @export
Status <- function(message = NULL, details = NULL, code = NULL) {
    structure(list(message = message, details = details, code = code), class = "gar_Status")
}

#' Binding Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Associates `members` with a `role`.
#' 
#' @param role Role that is assigned to `members`
#' @param members Specifies the identities requesting access for a Cloud Platform resource
#' 
#' @return Binding object
#' 
#' @family Binding functions
#' @export
Binding <- function(role = NULL, members = NULL) {
    structure(list(role = role, members = members), class = "gar_Binding")
}

#' UpdateDatabaseDdlRequest Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Enqueues the given DDL statements to be applied, in order but notnecessarily all at once, to the database schema at some point (orpoints) in the future. The server checks that the statementsare executable (syntactically valid, name tables that exist, etc.)before enqueueing them, but they may still fail uponlater execution (e.g., if a statement from another batch ofstatements is applied first and it conflicts in some way, or ifthere is some data-related problem like a `NULL` value in a column towhich `NOT NULL` would be added). If a statement fails, allsubsequent statements in the batch are automatically cancelled.Each batch of statements is assigned a name which can be used withthe Operations API to monitorprogress. See theoperation_id field for moredetails.
#' 
#' @param statements DDL statements to be applied to the database
#' @param operationId If empty, the new update request is assigned an
#' 
#' @return UpdateDatabaseDdlRequest object
#' 
#' @family UpdateDatabaseDdlRequest functions
#' @export
UpdateDatabaseDdlRequest <- function(statements = NULL, operationId = NULL) {
    structure(list(statements = statements, operationId = operationId), class = "gar_UpdateDatabaseDdlRequest")
}

#' PartialResultSet Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Partial results from a streaming read or SQL query. Streaming reads andSQL queries better tolerate large result sets, large rows, and largevalues, but are a little trickier to consume.
#' 
#' @param stats Query plan and execution statistics for the query that produced this
#' @param chunkedValue If true, then the final value in values is chunked, and must
#' @param metadata Metadata about the result set, such as row type information
#' @param values A streamed result set consists of a stream of values, which might
#' @param resumeToken Streaming calls might be interrupted for a variety of reasons, such
#' 
#' @return PartialResultSet object
#' 
#' @family PartialResultSet functions
#' @export
PartialResultSet <- function(stats = NULL, chunkedValue = NULL, metadata = NULL, 
    values = NULL, resumeToken = NULL) {
    structure(list(stats = stats, chunkedValue = chunkedValue, metadata = metadata, 
        values = values, resumeToken = resumeToken), class = "gar_PartialResultSet")
}

#' ListOperationsResponse Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' The response message for Operations.ListOperations.
#' 
#' @param nextPageToken The standard List next-page token
#' @param operations A list of operations that matches the specified filter in the request
#' 
#' @return ListOperationsResponse object
#' 
#' @family ListOperationsResponse functions
#' @export
ListOperationsResponse <- function(nextPageToken = NULL, operations = NULL) {
    structure(list(nextPageToken = nextPageToken, operations = operations), class = "gar_ListOperationsResponse")
}

#' UpdateInstanceMetadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata type for the operation returned byUpdateInstance.
#' 
#' @param instance The desired end state of the update
#' @param startTime The time at which UpdateInstance
#' @param cancelTime The time at which this operation was cancelled
#' @param endTime The time at which this operation failed or was completed successfully
#' 
#' @return UpdateInstanceMetadata object
#' 
#' @family UpdateInstanceMetadata functions
#' @export
UpdateInstanceMetadata <- function(instance = NULL, startTime = NULL, cancelTime = NULL, 
    endTime = NULL) {
    structure(list(instance = instance, startTime = startTime, cancelTime = cancelTime, 
        endTime = endTime), class = "gar_UpdateInstanceMetadata")
}


#' ResultSetMetadata Object
#' 
#' @details 
#' Autogenerated via \code{\link[googleAuthR]{gar_create_api_objects}}
#' Metadata about a ResultSet or PartialResultSet.
#' 
#' @param rowType Indicates the field names and types for the rows in the result
#' @param transaction If the read or SQL query began a transaction as a side-effect, the
#' 
#' @return ResultSetMetadata object
#' 
#' @family ResultSetMetadata functions
#' @export


ResultSetMetadata <- function(rowType = NULL, transaction = NULL) {
    
    
    
    structure(list(rowType = rowType, transaction = transaction), class = "gar_ResultSetMetadata")
}

